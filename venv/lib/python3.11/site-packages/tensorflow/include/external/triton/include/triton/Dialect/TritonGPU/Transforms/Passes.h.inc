/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
#define GEN_PASS_DECL_TRITONGPUCOALESCE
#define GEN_PASS_DECL_TRITONGPUDECOMPOSECONVERSIONS
#define GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#define GEN_PASS_DECL_TRITONGPUPIPELINE
#define GEN_PASS_DECL_TRITONGPUPREFETCH
#define GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#define GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// TritonGPUAccelerateMatmul
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
struct TritonGPUAccelerateMatmulOptions {
  int32_t computeCapability = 80;
};
#undef GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
#endif // GEN_PASS_DECL_TRITONGPUACCELERATEMATMUL
#ifdef GEN_PASS_DEF_TRITONGPUACCELERATEMATMUL
namespace impl {

template <typename DerivedT>
class TritonGPUAccelerateMatmulBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAccelerateMatmulBase;

  TritonGPUAccelerateMatmulBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAccelerateMatmulBase(const TritonGPUAccelerateMatmulBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-accelerate-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-accelerate-matmul"; }

  ::llvm::StringRef getDescription() const override { return "accelerate matmul"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAccelerateMatmul");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAccelerateMatmul"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAccelerateMatmulBase<DerivedT>)

  TritonGPUAccelerateMatmulBase(const TritonGPUAccelerateMatmulOptions &options) : TritonGPUAccelerateMatmulBase() {
    computeCapability = options.computeCapability;
  }
protected:
  ::mlir::Pass::Option<int32_t> computeCapability{*this, "compute-capability", ::llvm::cl::desc("device compute capability"), ::llvm::cl::init(80)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUACCELERATEMATMUL
#endif // GEN_PASS_DEF_TRITONGPUACCELERATEMATMUL

//===----------------------------------------------------------------------===//
// TritonGPUCoalesce
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUCOALESCE
#undef GEN_PASS_DECL_TRITONGPUCOALESCE
#endif // GEN_PASS_DECL_TRITONGPUCOALESCE
#ifdef GEN_PASS_DEF_TRITONGPUCOALESCE
namespace impl {

template <typename DerivedT>
class TritonGPUCoalesceBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCoalesceBase;

  TritonGPUCoalesceBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCoalesceBase(const TritonGPUCoalesceBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-coalesce");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-coalesce"; }

  ::llvm::StringRef getDescription() const override { return "coalesce"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCoalesce");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCoalesce"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCoalesceBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUCOALESCE
#endif // GEN_PASS_DEF_TRITONGPUCOALESCE

//===----------------------------------------------------------------------===//
// TritonGPUDecomposeConversions
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUDECOMPOSECONVERSIONS
#undef GEN_PASS_DECL_TRITONGPUDECOMPOSECONVERSIONS
#endif // GEN_PASS_DECL_TRITONGPUDECOMPOSECONVERSIONS
#ifdef GEN_PASS_DEF_TRITONGPUDECOMPOSECONVERSIONS
namespace impl {

template <typename DerivedT>
class TritonGPUDecomposeConversionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUDecomposeConversionsBase;

  TritonGPUDecomposeConversionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUDecomposeConversionsBase(const TritonGPUDecomposeConversionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-decompose-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-decompose-conversions"; }

  ::llvm::StringRef getDescription() const override { return "Decompose convert[distributed -> dotOperand] into convert[distributed -> shared -> dotOperand]"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUDecomposeConversions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUDecomposeConversions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUDecomposeConversionsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUDECOMPOSECONVERSIONS
#endif // GEN_PASS_DEF_TRITONGPUDECOMPOSECONVERSIONS

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeDotOperands
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#undef GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#endif // GEN_PASS_DECL_TRITONGPUOPTIMIZEDOTOPERANDS
#ifdef GEN_PASS_DEF_TRITONGPUOPTIMIZEDOTOPERANDS
namespace impl {

template <typename DerivedT>
class TritonGPUOptimizeDotOperandsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeDotOperandsBase;

  TritonGPUOptimizeDotOperandsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeDotOperandsBase(const TritonGPUOptimizeDotOperandsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-dot-operands");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-dot-operands"; }

  ::llvm::StringRef getDescription() const override { return "fuse transpositions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeDotOperands");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeDotOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeDotOperandsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUOPTIMIZEDOTOPERANDS
#endif // GEN_PASS_DEF_TRITONGPUOPTIMIZEDOTOPERANDS

//===----------------------------------------------------------------------===//
// TritonGPUPipeline
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUPIPELINE
struct TritonGPUPipelineOptions {
  int32_t numStages = 2;
};
#undef GEN_PASS_DECL_TRITONGPUPIPELINE
#endif // GEN_PASS_DECL_TRITONGPUPIPELINE
#ifdef GEN_PASS_DEF_TRITONGPUPIPELINE
namespace impl {

template <typename DerivedT>
class TritonGPUPipelineBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPipelineBase;

  TritonGPUPipelineBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPipelineBase(const TritonGPUPipelineBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-pipeline");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-pipeline"; }

  ::llvm::StringRef getDescription() const override { return "pipeline"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPipeline");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPipeline"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::scf::SCFDialect>();

  registry.insert<mlir::arith::ArithDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPipelineBase<DerivedT>)

  TritonGPUPipelineBase(const TritonGPUPipelineOptions &options) : TritonGPUPipelineBase() {
    numStages = options.numStages;
  }
protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc("number of pipeline stages"), ::llvm::cl::init(2)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUPIPELINE
#endif // GEN_PASS_DEF_TRITONGPUPIPELINE

//===----------------------------------------------------------------------===//
// TritonGPUPrefetch
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUPREFETCH
#undef GEN_PASS_DECL_TRITONGPUPREFETCH
#endif // GEN_PASS_DECL_TRITONGPUPREFETCH
#ifdef GEN_PASS_DEF_TRITONGPUPREFETCH
namespace impl {

template <typename DerivedT>
class TritonGPUPrefetchBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPrefetchBase;

  TritonGPUPrefetchBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPrefetchBase(const TritonGPUPrefetchBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-prefetch");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-prefetch"; }

  ::llvm::StringRef getDescription() const override { return "prefetch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPrefetch");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPrefetch"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::scf::SCFDialect>();

  registry.insert<mlir::arith::ArithDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPrefetchBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUPREFETCH
#endif // GEN_PASS_DEF_TRITONGPUPREFETCH

//===----------------------------------------------------------------------===//
// TritonGPURemoveLayoutConversions
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#undef GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#endif // GEN_PASS_DECL_TRITONGPUREMOVELAYOUTCONVERSIONS
#ifdef GEN_PASS_DEF_TRITONGPUREMOVELAYOUTCONVERSIONS
namespace impl {

template <typename DerivedT>
class TritonGPURemoveLayoutConversionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPURemoveLayoutConversionsBase;

  TritonGPURemoveLayoutConversionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPURemoveLayoutConversionsBase(const TritonGPURemoveLayoutConversionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-remove-layout-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-remove-layout-conversions"; }

  ::llvm::StringRef getDescription() const override { return "remove superfluous layout conversions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPURemoveLayoutConversions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPURemoveLayoutConversions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPURemoveLayoutConversionsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUREMOVELAYOUTCONVERSIONS
#endif // GEN_PASS_DEF_TRITONGPUREMOVELAYOUTCONVERSIONS

//===----------------------------------------------------------------------===//
// TritonGPUReorderInstructions
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#undef GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#endif // GEN_PASS_DECL_TRITONGPUREORDERINSTRUCTIONS
#ifdef GEN_PASS_DEF_TRITONGPUREORDERINSTRUCTIONS
namespace impl {

template <typename DerivedT>
class TritonGPUReorderInstructionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReorderInstructionsBase;

  TritonGPUReorderInstructionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReorderInstructionsBase(const TritonGPUReorderInstructionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reorder-instructions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reorder-instructions"; }

  ::llvm::StringRef getDescription() const override { return "Reorder instructions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReorderInstructions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReorderInstructions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReorderInstructionsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONGPUREORDERINSTRUCTIONS
#endif // GEN_PASS_DEF_TRITONGPUREORDERINSTRUCTIONS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// TritonGPUAccelerateMatmul Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUAccelerateMatmul() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUAccelerateMatmulPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUAccelerateMatmulPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUAccelerateMatmulPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUCoalesce Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUCoalesce() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUCoalescePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUCoalescePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUCoalescePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUDecomposeConversions Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUDecomposeConversions() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUDecomposeConversionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUDecomposeConversionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUDecomposeConversionsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUOptimizeDotOperands Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUOptimizeDotOperands() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUOptimizeDotOperandsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUOptimizeDotOperandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUOptimizeDotOperandsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUPipeline Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPipeline() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUPipelinePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUPipelinePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUPipelinePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUPrefetch Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPrefetch() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUPrefetchPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUPrefetchPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUPrefetchPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPURemoveLayoutConversions Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPURemoveLayoutConversions() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPURemoveLayoutConversionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPURemoveLayoutConversionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPURemoveLayoutConversionsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPUReorderInstructions Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUReorderInstructions() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUReorderInstructionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonGPUReorderInstructionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createTritonGPUReorderInstructionsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonGPU Registration
//===----------------------------------------------------------------------===//

inline void registerTritonGPUPasses() {
  registerTritonGPUAccelerateMatmul();
  registerTritonGPUCoalesce();
  registerTritonGPUDecomposeConversions();
  registerTritonGPUOptimizeDotOperands();
  registerTritonGPUPipeline();
  registerTritonGPUPrefetch();
  registerTritonGPURemoveLayoutConversions();
  registerTritonGPUReorderInstructions();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class TritonGPUAccelerateMatmulBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUAccelerateMatmulBase;

  TritonGPUAccelerateMatmulBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUAccelerateMatmulBase(const TritonGPUAccelerateMatmulBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-accelerate-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-accelerate-matmul"; }

  ::llvm::StringRef getDescription() const override { return "accelerate matmul"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUAccelerateMatmul");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUAccelerateMatmul"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUAccelerateMatmulBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> computeCapability{*this, "compute-capability", ::llvm::cl::desc("device compute capability"), ::llvm::cl::init(80)};
};

template <typename DerivedT>
class TritonGPUCoalesceBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUCoalesceBase;

  TritonGPUCoalesceBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUCoalesceBase(const TritonGPUCoalesceBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-coalesce");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-coalesce"; }

  ::llvm::StringRef getDescription() const override { return "coalesce"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUCoalesce");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUCoalesce"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUCoalesceBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUDecomposeConversionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUDecomposeConversionsBase;

  TritonGPUDecomposeConversionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUDecomposeConversionsBase(const TritonGPUDecomposeConversionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-decompose-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-decompose-conversions"; }

  ::llvm::StringRef getDescription() const override { return "Decompose convert[distributed -> dotOperand] into convert[distributed -> shared -> dotOperand]"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUDecomposeConversions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUDecomposeConversions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUDecomposeConversionsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUOptimizeDotOperandsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUOptimizeDotOperandsBase;

  TritonGPUOptimizeDotOperandsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUOptimizeDotOperandsBase(const TritonGPUOptimizeDotOperandsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-optimize-dot-operands");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-optimize-dot-operands"; }

  ::llvm::StringRef getDescription() const override { return "fuse transpositions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUOptimizeDotOperands");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUOptimizeDotOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUOptimizeDotOperandsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUPipelineBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPipelineBase;

  TritonGPUPipelineBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPipelineBase(const TritonGPUPipelineBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-pipeline");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-pipeline"; }

  ::llvm::StringRef getDescription() const override { return "pipeline"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPipeline");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPipeline"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::scf::SCFDialect>();

  registry.insert<mlir::arith::ArithDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPipelineBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numStages{*this, "num-stages", ::llvm::cl::desc("number of pipeline stages"), ::llvm::cl::init(2)};
};

template <typename DerivedT>
class TritonGPUPrefetchBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUPrefetchBase;

  TritonGPUPrefetchBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUPrefetchBase(const TritonGPUPrefetchBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-prefetch");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-prefetch"; }

  ::llvm::StringRef getDescription() const override { return "prefetch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUPrefetch");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUPrefetch"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::scf::SCFDialect>();

  registry.insert<mlir::arith::ArithDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUPrefetchBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPURemoveLayoutConversionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPURemoveLayoutConversionsBase;

  TritonGPURemoveLayoutConversionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPURemoveLayoutConversionsBase(const TritonGPURemoveLayoutConversionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-remove-layout-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-remove-layout-conversions"; }

  ::llvm::StringRef getDescription() const override { return "remove superfluous layout conversions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPURemoveLayoutConversions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPURemoveLayoutConversions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPURemoveLayoutConversionsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonGPUReorderInstructionsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonGPUReorderInstructionsBase;

  TritonGPUReorderInstructionsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonGPUReorderInstructionsBase(const TritonGPUReorderInstructionsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tritongpu-reorder-instructions");
  }
  ::llvm::StringRef getArgument() const override { return "tritongpu-reorder-instructions"; }

  ::llvm::StringRef getDescription() const override { return "Reorder instructions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonGPUReorderInstructions");
  }
  ::llvm::StringRef getName() const override { return "TritonGPUReorderInstructions"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::triton::gpu::TritonGPUDialect>();

  registry.insert<mlir::triton::TritonDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonGPUReorderInstructionsBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
