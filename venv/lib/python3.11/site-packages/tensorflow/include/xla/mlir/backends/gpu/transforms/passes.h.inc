/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ADDCONCURRENTREGIONSPASS
#define GEN_PASS_DECL_ADDHLOTRACEANNOTATIONSPASS
#define GEN_PASS_DECL_CONVERTGPUTOGPURUNTIMEPASS
#define GEN_PASS_DECL_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#define GEN_PASS_DECL_CONVERTLMHLOTOGPULAUNCHPASS
#define GEN_PASS_DECL_CONVERTLMHLOTOGPURUNTIMEPASS
#define GEN_PASS_DECL_CONVERTMEMREFGETGLOBALTOARGPASS
#define GEN_PASS_DECL_OUTLINEGPUGRAPHSPASS
#define GEN_PASS_DECL_STREAMASSIGNMENTPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AddConcurrentRegionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ADDCONCURRENTREGIONSPASS
#undef GEN_PASS_DECL_ADDCONCURRENTREGIONSPASS
#endif // GEN_PASS_DECL_ADDCONCURRENTREGIONSPASS
#ifdef GEN_PASS_DEF_ADDCONCURRENTREGIONSPASS
namespace impl {

template <typename DerivedT>
class AddConcurrentRegionsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddConcurrentRegionsPassBase;

  AddConcurrentRegionsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddConcurrentRegionsPassBase(const AddConcurrentRegionsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-add-concurrent-regions");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-add-concurrent-regions"; }

  ::llvm::StringRef getDescription() const override { return "Identify and mark concurrent regions in CUDA graph capture functions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddConcurrentRegionsPass");
  }
  ::llvm::StringRef getName() const override { return "AddConcurrentRegionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddConcurrentRegionsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ADDCONCURRENTREGIONSPASS
#endif // GEN_PASS_DEF_ADDCONCURRENTREGIONSPASS

//===----------------------------------------------------------------------===//
// AddHloTraceAnnotationsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ADDHLOTRACEANNOTATIONSPASS
#undef GEN_PASS_DECL_ADDHLOTRACEANNOTATIONSPASS
#endif // GEN_PASS_DECL_ADDHLOTRACEANNOTATIONSPASS
#ifdef GEN_PASS_DEF_ADDHLOTRACEANNOTATIONSPASS
namespace impl {

template <typename DerivedT>
class AddHloTraceAnnotationsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddHloTraceAnnotationsPassBase;

  AddHloTraceAnnotationsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddHloTraceAnnotationsPassBase(const AddHloTraceAnnotationsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-add-hlo-trace-annotations");
  }
  ::llvm::StringRef getArgument() const override { return "xla-add-hlo-trace-annotations"; }

  ::llvm::StringRef getDescription() const override { return "Adds HLO trace annotations to the supported operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddHloTraceAnnotationsPass");
  }
  ::llvm::StringRef getName() const override { return "AddHloTraceAnnotationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddHloTraceAnnotationsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ADDHLOTRACEANNOTATIONSPASS
#endif // GEN_PASS_DEF_ADDHLOTRACEANNOTATIONSPASS

//===----------------------------------------------------------------------===//
// ConvertGpuToGpuRuntimePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTGPUTOGPURUNTIMEPASS
#undef GEN_PASS_DECL_CONVERTGPUTOGPURUNTIMEPASS
#endif // GEN_PASS_DECL_CONVERTGPUTOGPURUNTIMEPASS
#ifdef GEN_PASS_DEF_CONVERTGPUTOGPURUNTIMEPASS
namespace impl {

template <typename DerivedT>
class ConvertGpuToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertGpuToGpuRuntimePassBase;

  ConvertGpuToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuToGpuRuntimePassBase(const ConvertGpuToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts gpu operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuToGpuRuntimePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTGPUTOGPURUNTIMEPASS
#endif // GEN_PASS_DEF_CONVERTGPUTOGPURUNTIMEPASS

//===----------------------------------------------------------------------===//
// ConvertLmhloGpuToGpuRuntimePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#undef GEN_PASS_DECL_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#endif // GEN_PASS_DECL_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#ifdef GEN_PASS_DEF_CONVERTLMHLOGPUTOGPURUNTIMEPASS
namespace impl {

template <typename DerivedT>
class ConvertLmhloGpuToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloGpuToGpuRuntimePassBase;

  ConvertLmhloGpuToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloGpuToGpuRuntimePassBase(const ConvertLmhloGpuToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-gpu-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-gpu-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo_gpu operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloGpuToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloGpuToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloGpuToGpuRuntimePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTLMHLOGPUTOGPURUNTIMEPASS
#endif // GEN_PASS_DEF_CONVERTLMHLOGPUTOGPURUNTIMEPASS

//===----------------------------------------------------------------------===//
// ConvertLmhloToGpuLaunchPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLMHLOTOGPULAUNCHPASS
#undef GEN_PASS_DECL_CONVERTLMHLOTOGPULAUNCHPASS
#endif // GEN_PASS_DECL_CONVERTLMHLOTOGPULAUNCHPASS
#ifdef GEN_PASS_DEF_CONVERTLMHLOTOGPULAUNCHPASS
namespace impl {

template <typename DerivedT>
class ConvertLmhloToGpuLaunchPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloToGpuLaunchPassBase;

  ConvertLmhloToGpuLaunchPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloToGpuLaunchPassBase(const ConvertLmhloToGpuLaunchPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-to-gpu-launch");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-to-gpu-launch"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo fusions to Gpu dialect kernel launch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloToGpuLaunchPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloToGpuLaunchPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloToGpuLaunchPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTLMHLOTOGPULAUNCHPASS
#endif // GEN_PASS_DEF_CONVERTLMHLOTOGPULAUNCHPASS

//===----------------------------------------------------------------------===//
// ConvertLmhloToGpuRuntimePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTLMHLOTOGPURUNTIMEPASS
#undef GEN_PASS_DECL_CONVERTLMHLOTOGPURUNTIMEPASS
#endif // GEN_PASS_DECL_CONVERTLMHLOTOGPURUNTIMEPASS
#ifdef GEN_PASS_DEF_CONVERTLMHLOTOGPURUNTIMEPASS
namespace impl {

template <typename DerivedT>
class ConvertLmhloToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloToGpuRuntimePassBase;

  ConvertLmhloToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloToGpuRuntimePassBase(const ConvertLmhloToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloToGpuRuntimePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTLMHLOTOGPURUNTIMEPASS
#endif // GEN_PASS_DEF_CONVERTLMHLOTOGPURUNTIMEPASS

//===----------------------------------------------------------------------===//
// ConvertMemrefGetGlobalToArgPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTMEMREFGETGLOBALTOARGPASS
struct ConvertMemrefGetGlobalToArgPassOptions {
  int64_t min_num_elements_ = 0;
};
#undef GEN_PASS_DECL_CONVERTMEMREFGETGLOBALTOARGPASS
#endif // GEN_PASS_DECL_CONVERTMEMREFGETGLOBALTOARGPASS
#ifdef GEN_PASS_DEF_CONVERTMEMREFGETGLOBALTOARGPASS
namespace impl {

template <typename DerivedT>
class ConvertMemrefGetGlobalToArgPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertMemrefGetGlobalToArgPassBase;

  ConvertMemrefGetGlobalToArgPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMemrefGetGlobalToArgPassBase(const ConvertMemrefGetGlobalToArgPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-memref-get-global-to-arg");
  }
  ::llvm::StringRef getArgument() const override { return "xla-memref-get-global-to-arg"; }

  ::llvm::StringRef getDescription() const override { return "Converts memref.get_global corresponding to lmhlo constants"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMemrefGetGlobalToArgPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMemrefGetGlobalToArgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMemrefGetGlobalToArgPassBase<DerivedT>)

  ConvertMemrefGetGlobalToArgPassBase(const ConvertMemrefGetGlobalToArgPassOptions &options) : ConvertMemrefGetGlobalToArgPassBase() {
    min_num_elements_ = options.min_num_elements_;
  }
protected:
  ::mlir::Pass::Option<int64_t> min_num_elements_{*this, "min-num-elements", ::llvm::cl::desc("Do not convert `memref.get_global` operation if the number of elements is smaller than the given value."), ::llvm::cl::init(0)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTMEMREFGETGLOBALTOARGPASS
#endif // GEN_PASS_DEF_CONVERTMEMREFGETGLOBALTOARGPASS

//===----------------------------------------------------------------------===//
// OutlineGpuGraphsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OUTLINEGPUGRAPHSPASS
struct OutlineGpuGraphsPassOptions {
  int64_t min_graph_size_ = 2;
};
#undef GEN_PASS_DECL_OUTLINEGPUGRAPHSPASS
#endif // GEN_PASS_DECL_OUTLINEGPUGRAPHSPASS
#ifdef GEN_PASS_DEF_OUTLINEGPUGRAPHSPASS
namespace impl {

template <typename DerivedT>
class OutlineGpuGraphsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OutlineGpuGraphsPassBase;

  OutlineGpuGraphsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OutlineGpuGraphsPassBase(const OutlineGpuGraphsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-outline-gpu-graphs");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-outline-gpu-graphs"; }

  ::llvm::StringRef getDescription() const override { return "Outline sequences of Xla Gpu operations into CUDA Graphs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OutlineGpuGraphsPass");
  }
  ::llvm::StringRef getName() const override { return "OutlineGpuGraphsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OutlineGpuGraphsPassBase<DerivedT>)

  OutlineGpuGraphsPassBase(const OutlineGpuGraphsPassOptions &options) : OutlineGpuGraphsPassBase() {
    min_graph_size_ = options.min_graph_size_;
  }
protected:
  ::mlir::Pass::Option<int64_t> min_graph_size_{*this, "min_graph_size", ::llvm::cl::desc("The minimum size of the outlined CUDA graph function."), ::llvm::cl::init(2)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OUTLINEGPUGRAPHSPASS
#endif // GEN_PASS_DEF_OUTLINEGPUGRAPHSPASS

//===----------------------------------------------------------------------===//
// StreamAssignmentPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STREAMASSIGNMENTPASS
#undef GEN_PASS_DECL_STREAMASSIGNMENTPASS
#endif // GEN_PASS_DECL_STREAMASSIGNMENTPASS
#ifdef GEN_PASS_DEF_STREAMASSIGNMENTPASS
namespace impl {

template <typename DerivedT>
class StreamAssignmentPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = StreamAssignmentPassBase;

  StreamAssignmentPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StreamAssignmentPassBase(const StreamAssignmentPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-stream-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-stream-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Identify and mark concurrent regions in CUDA graph capture functions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StreamAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "StreamAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StreamAssignmentPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STREAMASSIGNMENTPASS
#endif // GEN_PASS_DEF_STREAMASSIGNMENTPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AddConcurrentRegionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerAddConcurrentRegionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAddConcurrentRegionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAddConcurrentRegionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAddConcurrentRegionsPass();
  });
}

//===----------------------------------------------------------------------===//
// AddHloTraceAnnotationsPass Registration
//===----------------------------------------------------------------------===//

inline void registerAddHloTraceAnnotationsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAddHloTraceAnnotationsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAddHloTraceAnnotationsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAddHloTraceAnnotationsPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertGpuToGpuRuntimePass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertGpuToGpuRuntimePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertGpuToGpuRuntimePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertGpuToGpuRuntimePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertGpuToGpuRuntimePass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLmhloGpuToGpuRuntimePass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLmhloGpuToGpuRuntimePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloGpuToGpuRuntimePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLmhloGpuToGpuRuntimePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloGpuToGpuRuntimePass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLmhloToGpuLaunchPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLmhloToGpuLaunchPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloToGpuLaunchPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLmhloToGpuLaunchPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloToGpuLaunchPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertLmhloToGpuRuntimePass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertLmhloToGpuRuntimePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloToGpuRuntimePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertLmhloToGpuRuntimePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertLmhloToGpuRuntimePass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertMemrefGetGlobalToArgPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertMemrefGetGlobalToArgPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMemrefGetGlobalToArgPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertMemrefGetGlobalToArgPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertMemrefGetGlobalToArgPass();
  });
}

//===----------------------------------------------------------------------===//
// OutlineGpuGraphsPass Registration
//===----------------------------------------------------------------------===//

inline void registerOutlineGpuGraphsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createOutlineGpuGraphsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOutlineGpuGraphsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createOutlineGpuGraphsPass();
  });
}

//===----------------------------------------------------------------------===//
// StreamAssignmentPass Registration
//===----------------------------------------------------------------------===//

inline void registerStreamAssignmentPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStreamAssignmentPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStreamAssignmentPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStreamAssignmentPass();
  });
}

//===----------------------------------------------------------------------===//
// GpuTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerGpuTransformsPasses() {
  registerAddConcurrentRegionsPass();
  registerAddHloTraceAnnotationsPass();
  registerConvertGpuToGpuRuntimePass();
  registerConvertLmhloGpuToGpuRuntimePass();
  registerConvertLmhloToGpuLaunchPass();
  registerConvertLmhloToGpuRuntimePass();
  registerConvertMemrefGetGlobalToArgPass();
  registerOutlineGpuGraphsPass();
  registerStreamAssignmentPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AddConcurrentRegionsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddConcurrentRegionsPassBase;

  AddConcurrentRegionsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddConcurrentRegionsPassBase(const AddConcurrentRegionsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-add-concurrent-regions");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-add-concurrent-regions"; }

  ::llvm::StringRef getDescription() const override { return "Identify and mark concurrent regions in CUDA graph capture functions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddConcurrentRegionsPass");
  }
  ::llvm::StringRef getName() const override { return "AddConcurrentRegionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddConcurrentRegionsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AddHloTraceAnnotationsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddHloTraceAnnotationsPassBase;

  AddHloTraceAnnotationsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddHloTraceAnnotationsPassBase(const AddHloTraceAnnotationsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-add-hlo-trace-annotations");
  }
  ::llvm::StringRef getArgument() const override { return "xla-add-hlo-trace-annotations"; }

  ::llvm::StringRef getDescription() const override { return "Adds HLO trace annotations to the supported operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddHloTraceAnnotationsPass");
  }
  ::llvm::StringRef getName() const override { return "AddHloTraceAnnotationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddHloTraceAnnotationsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertGpuToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertGpuToGpuRuntimePassBase;

  ConvertGpuToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertGpuToGpuRuntimePassBase(const ConvertGpuToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts gpu operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertGpuToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertGpuToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertGpuToGpuRuntimePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertLmhloGpuToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloGpuToGpuRuntimePassBase;

  ConvertLmhloGpuToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloGpuToGpuRuntimePassBase(const ConvertLmhloGpuToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-gpu-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-gpu-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo_gpu operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloGpuToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloGpuToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloGpuToGpuRuntimePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertLmhloToGpuLaunchPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloToGpuLaunchPassBase;

  ConvertLmhloToGpuLaunchPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloToGpuLaunchPassBase(const ConvertLmhloToGpuLaunchPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-to-gpu-launch");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-to-gpu-launch"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo fusions to Gpu dialect kernel launch"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloToGpuLaunchPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloToGpuLaunchPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloToGpuLaunchPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertLmhloToGpuRuntimePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertLmhloToGpuRuntimePassBase;

  ConvertLmhloToGpuRuntimePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertLmhloToGpuRuntimePassBase(const ConvertLmhloToGpuRuntimePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-lmhlo-to-gpu-runtime");
  }
  ::llvm::StringRef getArgument() const override { return "xla-lmhlo-to-gpu-runtime"; }

  ::llvm::StringRef getDescription() const override { return "Converts lmhlo operations to XLA Gpu runtime custom calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertLmhloToGpuRuntimePass");
  }
  ::llvm::StringRef getName() const override { return "ConvertLmhloToGpuRuntimePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertLmhloToGpuRuntimePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertMemrefGetGlobalToArgPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertMemrefGetGlobalToArgPassBase;

  ConvertMemrefGetGlobalToArgPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertMemrefGetGlobalToArgPassBase(const ConvertMemrefGetGlobalToArgPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-memref-get-global-to-arg");
  }
  ::llvm::StringRef getArgument() const override { return "xla-memref-get-global-to-arg"; }

  ::llvm::StringRef getDescription() const override { return "Converts memref.get_global corresponding to lmhlo constants"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertMemrefGetGlobalToArgPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertMemrefGetGlobalToArgPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertMemrefGetGlobalToArgPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> min_num_elements_{*this, "min-num-elements", ::llvm::cl::desc("Do not convert `memref.get_global` operation if the number of elements is smaller than the given value."), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class OutlineGpuGraphsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = OutlineGpuGraphsPassBase;

  OutlineGpuGraphsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  OutlineGpuGraphsPassBase(const OutlineGpuGraphsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-outline-gpu-graphs");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-outline-gpu-graphs"; }

  ::llvm::StringRef getDescription() const override { return "Outline sequences of Xla Gpu operations into CUDA Graphs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OutlineGpuGraphsPass");
  }
  ::llvm::StringRef getName() const override { return "OutlineGpuGraphsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OutlineGpuGraphsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> min_graph_size_{*this, "min_graph_size", ::llvm::cl::desc("The minimum size of the outlined CUDA graph function."), ::llvm::cl::init(2)};
};

template <typename DerivedT>
class StreamAssignmentPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = StreamAssignmentPassBase;

  StreamAssignmentPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StreamAssignmentPassBase(const StreamAssignmentPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-stream-assignment");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-stream-assignment"; }

  ::llvm::StringRef getDescription() const override { return "Identify and mark concurrent regions in CUDA graph capture functions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StreamAssignmentPass");
  }
  ::llvm::StringRef getName() const override { return "StreamAssignmentPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StreamAssignmentPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
